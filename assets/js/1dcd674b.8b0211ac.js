"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[51],{3905:(e,r,t)=>{t.d(r,{Zo:()=>s,kt:()=>d});var n=t(7294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function a(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?a(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)t=a[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=n.createContext({}),p=function(e){var r=n.useContext(c),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},s=function(e){var r=p(e.components);return n.createElement(c.Provider,{value:r},e.children)},g="mdxType",h={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},m=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),g=p(t),m=o,d=g["".concat(c,".").concat(m)]||g[m]||h[m]||a;return t?n.createElement(d,i(i({ref:r},s),{},{components:t})):n.createElement(d,i({ref:r},s))}));function d(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=m;var l={};for(var c in r)hasOwnProperty.call(r,c)&&(l[c]=r[c]);l.originalType=e,l[g]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<a;p++)i[p]=t[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8202:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var n=t(7462),o=(t(7294),t(3905));const a={},i="Greedy Graph Coloring Algorithm",l={unversionedId:"algorithms/coloring/greedy-graph-coloring",id:"algorithms/coloring/greedy-graph-coloring",title:"Greedy Graph Coloring Algorithm",description:"Greedy Graph Coloring computes a coloring of the vertices of a (simple, connected) graph such that no two adjacent",source:"@site/docs/algorithms/coloring/greedy-graph-coloring.md",sourceDirName:"algorithms/coloring",slug:"/algorithms/coloring/greedy-graph-coloring",permalink:"/graaf/docs/algorithms/coloring/greedy-graph-coloring",draft:!1,editUrl:"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/coloring/greedy-graph-coloring.md",tags:[],version:"current",frontMatter:{},sidebar:"algorithmSidebar",previous:{title:"Graph Coloring Algorithms",permalink:"/graaf/docs/category/graph-coloring-algorithms"},next:{title:"Cycle Detection Algorithms",permalink:"/graaf/docs/category/cycle-detection-algorithms"}},c={},p=[{value:"Syntax",id:"syntax",level:2}],s={toc:p},g="wrapper";function h(e){let{components:r,...t}=e;return(0,o.kt)(g,(0,n.Z)({},s,t,{components:r,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"greedy-graph-coloring-algorithm"},"Greedy Graph Coloring Algorithm"),(0,o.kt)("p",null,"Greedy Graph Coloring computes a coloring of the vertices of a (simple, connected) graph such that no two adjacent\nvertices have the same color."),(0,o.kt)("p",null,"If the graph has different connected components, each component will be treated as a separate simple connected graph."),(0,o.kt)("p",null,"The algorithm is heuristic and does not guarantee an optimal number of different colors (that is, equal to the chromatic\nnumber of a simple, connected graph)."),(0,o.kt)("p",null,"Colors are represented by the numbers 0, 1, 2,... The greedy algorithm considers the vertices of the graph in sequence\nand assigns each vertex its first available color, i.e. the color with the smallest number that is not already used by\none of its neighbors."),(0,o.kt)("p",null,"The overall worst-case time complexity of the algorithm is ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n^2)"),". In cases where the graph has a fixed degree (a\nconstant number of neighbors for each vertex), the time complexity can be approximated as ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n)"),". However, if the graph\nis highly connected (dense) and approaches a complete graph, the time complexity could approach ",(0,o.kt)("inlineCode",{parentName:"p"},"O(n^2)"),"."),(0,o.kt)("p",null,"If no coloring is possible, an empty ",(0,o.kt)("inlineCode",{parentName:"p"},"unordered_map")," is returned. This is the case when the graph contains no vertices."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Greedy_coloring"},"wikipedia")),(0,o.kt)("h2",{id:"syntax"},"Syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename GRAPH>\nstd::unordered_map<vertex_id_t, int> greedy_graph_coloring(const GRAPH& graph);\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"graph")," A graph to perform graph coloring on."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"return")," An unordered_map where keys are vertex identifiers and values are their respective colors. If no coloring\nis possible, an empty ",(0,o.kt)("inlineCode",{parentName:"li"},"unordered_map")," is returned.")))}h.isMDXComponent=!0}}]);