"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[646],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>u});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},h=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,h=o(e,["components","mdxType","originalType","parentName"]),c=p(a),m=n,u=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return a?r.createElement(u,l(l({ref:t},h),{},{components:a})):r.createElement(u,l({ref:t},h))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:n,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},8469:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const i={},l="Depth First Search (DFS)",o={unversionedId:"algorithms/traversal/depth-first-search",id:"algorithms/traversal/depth-first-search",title:"Depth First Search (DFS)",description:"Depth First Search (DFS) Algorithm",source:"@site/docs/algorithms/traversal/depth-first-search.md",sourceDirName:"algorithms/traversal",slug:"/algorithms/traversal/depth-first-search",permalink:"/graaf/docs/algorithms/traversal/depth-first-search",draft:!1,editUrl:"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/traversal/depth-first-search.md",tags:[],version:"current",frontMatter:{},sidebar:"algorithmSidebar",previous:{title:"Breadth First Search (BFS)",permalink:"/graaf/docs/algorithms/traversal/breadth-first-search"}},s={},p=[{value:"Depth First Search (DFS) Algorithm",id:"depth-first-search-dfs-algorithm",level:2},{value:"DFS is particularly useful for:",id:"dfs-is-particularly-useful-for",level:3},{value:"Limitations of DFS:",id:"limitations-of-dfs",level:4},{value:"Complexity and Performance:",id:"complexity-and-performance",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Explanation of Parameters:",id:"explanation-of-parameters",level:3}],h={toc:p},c="wrapper";function d(e){let{components:t,...a}=e;return(0,n.kt)(c,(0,r.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"depth-first-search-dfs"},"Depth First Search (DFS)"),(0,n.kt)("h2",{id:"depth-first-search-dfs-algorithm"},"Depth First Search (DFS) Algorithm"),(0,n.kt)("p",null,"Depth First Search (DFS) is a fundamental graph traversal algorithm used to explore and analyze graphs, whether they are\ndirected or undirected.\nDFS traverses deeper into the graph before backtracking to explore other branches."),(0,n.kt)("p",null,"The DFS algorithm can be succinctly described using the following steps:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Begin by selecting a source node as the starting point of the traversal and push it onto a stack data structure.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"While the stack is not empty, repeat the following steps:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"a. Pop a node from the top of the stack."),(0,n.kt)("li",{parentName:"ul"},"b. Process the popped node, which may involve examining its attributes, marking it as visited, or performing other\nrelevant operations."),(0,n.kt)("li",{parentName:"ul"},"c. Push all unvisited neighbors of the popped node onto the stack."))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Continue this process until the stack becomes empty, indicating that all reachable nodes have been visited."))),(0,n.kt)("p",null,"The main difference to the BFS is the use of a stack instead of a queue."),(0,n.kt)("h3",{id:"dfs-is-particularly-useful-for"},"DFS is particularly useful for:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Topological Sorting:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Finds a linear ordering of nodes that respects the partial order imposed by directed edges in a directed acyclic\ngraph."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Pathfinding:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Can be used to find paths between nodes, although it may not always find the shortest path."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Solving Mazes:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Navigates through maze-like structures to find a way from a starting point to an end point."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Detecting Cycles:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Helps identify cycles in a graph, which is valuable for various applications.")))),(0,n.kt)("h4",{id:"limitations-of-dfs"},"Limitations of DFS:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Completeness:")," DFS may not explore all nodes in disconnected graphs unless modifications are made to the\nalgorithm.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Infinite Graphs:")," DFS can get stuck in an infinite loop if applied to graphs with infinite branches.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Performance on Dense Graphs:")," In dense graphs, DFS might explore many nodes before reaching a solution, making it\nless efficient compared to other algorithms.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"No Guarantee of Optimality:")," Like BFS, DFS may not always find the optimal solution, especially in cases where the\ngraph has weighted edges or other complexities.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Memory Usage:")," DFS on deep graphs may lead to excessive recursion and memory consumption due to the call stack.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Biased Exploration:")," DFS can lead to biased exploration when some branches are deeper than others, potentially\nmissing relevant solutions."))),(0,n.kt)("h3",{id:"complexity-and-performance"},"Complexity and Performance:"),(0,n.kt)("p",null,"The DFS algorithm is implemented with a stack and runs in ",(0,n.kt)("inlineCode",{parentName:"p"},"O(|V| + |E|)")," time complexity for connected graphs,\nwhere ",(0,n.kt)("inlineCode",{parentName:"p"},"|E|")," is the number of edges and ",(0,n.kt)("inlineCode",{parentName:"p"},"|V|")," the number of vertices in the graph."),(0,n.kt)("p",null,"In summary, Depth First Search is a powerful and versatile algorithm for exploring graphs, but its limitations in\nhandling weighted graphs and negative edge weights should be considered. It provides a straightforward way to explore a\ngraph layer by layer and is particularly useful for unweighted graph scenarios and connectivity analysis."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Depth-first_search"},"wikipedia")),(0,n.kt)("h2",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"The dfs_termination_strategy returns true when a certain condition is met, causing to terminate. The dfs_edge_callback\nis a function that is used as a callback during the DFS traversal to perform some action whenever an edge is traversed."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"template <\n    typename V, typename E, graph_type T,\n    typename EDGE_CALLBACK_T = detail::noop_callback,\n    typename SEARCH_TERMINATION_STRATEGY_T = detail::exhaustive_search_strategy>\n  requires std::invocable<EDGE_CALLBACK_T &, edge_id_t &> &&\n           std::is_invocable_r_v<bool, SEARCH_TERMINATION_STRATEGY_T &,\n                                 vertex_id_t>\nvoid depth_first_traverse(\n    const graph<V, E, T> &graph, vertex_id_t start_vertex,\n    const EDGE_CALLBACK_T &edge_callback,\n    const SEARCH_TERMINATION_STRATEGY_T &search_termination_strategy =\n        SEARCH_TERMINATION_STRATEGY_T{});\n")),(0,n.kt)("h3",{id:"explanation-of-parameters"},"Explanation of Parameters:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"graph"),": The graph to traverse. This parameter represents the graph data structure on which the traversal will be\nperformed."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"start_vertex"),": Vertex id where the traversal should be started. This parameter specifies the initial vertex from\nwhich the traversal begins."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"edge_callback"),": A callback function that is called for each traversed edge. It should be invocable with\nan ",(0,n.kt)("inlineCode",{parentName:"li"},"edge_id_t")," object, representing an edge in the graph."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"search_termination_strategy"),": A unary predicate that indicates whether the traversal should continue or not. The\ntraversal continues while this predicate returns ",(0,n.kt)("inlineCode",{parentName:"li"},"false"),". This parameter is optional and defaults to a predefined\nsearch termination strategy, which traverses the graph exhaustively."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"return"),": The provided code does not explicitly return a value. The traversal is performed by visiting vertices and\nedges in the graph based on the specified parameters.")))}d.isMDXComponent=!0}}]);