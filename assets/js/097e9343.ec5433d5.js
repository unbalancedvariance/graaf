"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[575],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var h=a.createContext({}),l=function(e){var t=a.useContext(h),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return a.createElement(h.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,h=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=l(r),d=n,u=c["".concat(h,".").concat(d)]||c[d]||m[d]||o;return r?a.createElement(u,i(i({ref:t},p),{},{components:r})):a.createElement(u,i({ref:t},p))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=d;var s={};for(var h in t)hasOwnProperty.call(t,h)&&(s[h]=t[h]);s.originalType=e,s[c]="string"==typeof e?e:n,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},9346:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=r(7462),n=(r(7294),r(3905));const o={},i="A* Search Algorithm",s={unversionedId:"algorithms/shortest-path/a-star",id:"algorithms/shortest-path/a-star",title:"A* Search Algorithm",description:"A\\* computes the shortest path between a starting vertex and a target vertex in weighted and unweighted graphs.",source:"@site/docs/algorithms/shortest-path/a-star.md",sourceDirName:"algorithms/shortest-path",slug:"/algorithms/shortest-path/a-star",permalink:"/graaf/docs/algorithms/shortest-path/a-star",draft:!1,editUrl:"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/shortest-path/a-star.md",tags:[],version:"current",frontMatter:{},sidebar:"algorithmSidebar",previous:{title:"Shortest Path Algorithms",permalink:"/graaf/docs/category/shortest-path-algorithms"},next:{title:"Bellman-Ford Shortest Path",permalink:"/graaf/docs/algorithms/shortest-path/bellman-ford"}},h={},l=[{value:"Syntax",id:"syntax",level:2}],p={toc:l},c="wrapper";function m(e){let{components:t,...r}=e;return(0,n.kt)(c,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"a-search-algorithm"},"A* Search Algorithm"),(0,n.kt)("p",null,"A","*"," computes the shortest path between a starting vertex and a target vertex in weighted and unweighted graphs.\nIt can be seen as an extension of Dijkstra's classical shortest paths algorithm. The implementation of A","*"," also tries to\nfollow ",(0,n.kt)("inlineCode",{parentName:"p"},"dijkstra_shortest_path")," closely where appropriate. Compared to Dijkstra's algorithm, A","*"," only finds the shortest\npath from a start vertex to a target vertex, and not the shortest path to all possible target vertices. Another\ndifference is that A","*"," uses a heuristic function to achieve better performance."),(0,n.kt)("p",null,"At each iteration of its main loop, A","*"," needs to determine which of its paths to extend. It does so by minimizing the\nso-called ",(0,n.kt)("inlineCode",{parentName:"p"},"f_score"),"."),(0,n.kt)("p",null,"In A","*",", the ",(0,n.kt)("inlineCode",{parentName:"p"},"f_score")," represents the estimated total cost of the path from the start vertex to the goal vertex through\nthe current vertex. It's a combination of two components:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("inlineCode",{parentName:"li"},"g_score"),": The actual cost of the path from the start vertex to the current vertex."),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("inlineCode",{parentName:"li"},"h_score")," (heuristic score): An estimate of the cost required from the current vertex to the goal vertex.")),(0,n.kt)("p",null,"A","*"," tries to minimize the ",(0,n.kt)("inlineCode",{parentName:"p"},"f_score")," for each vertex as it explores the graph. The idea is to prioritize exploring\nvertices that have lower ",(0,n.kt)("inlineCode",{parentName:"p"},"f_score")," values, as they are expected to lead to potentially better paths."),(0,n.kt)("p",null,"Mathematically, ",(0,n.kt)("inlineCode",{parentName:"p"},"f_score")," is often defined as:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"f_score = g_score + h_score\n")),(0,n.kt)("p",null,"Where:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"g_score")," is the cost of the path from the start vertex to the current vertex."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"h_score")," is the heuristic estimate of the cost from the current vertex to the goal vertex.")),(0,n.kt)("p",null,"In the implementation, the heuristic function ",(0,n.kt)("inlineCode",{parentName:"p"},"heuristic")," provides an estimate of ",(0,n.kt)("inlineCode",{parentName:"p"},"h_score")," for each vertex, and the\nactual cost of the path from the start vertex to the current vertex is stored in the ",(0,n.kt)("inlineCode",{parentName:"p"},"g_score")," unordered map, as the\nalgorithm progresses."),(0,n.kt)("p",null,"In the implementation, ",(0,n.kt)("inlineCode",{parentName:"p"},"dist_from_start")," from path_vertex represents the ",(0,n.kt)("inlineCode",{parentName:"p"},"f_score")," of the path."),(0,n.kt)("p",null,"The time complexity of A","*"," depends on the provided heuristic function. In the worst case of an unbounded search space,\nthe number of nodes expanded is exponential in the depth of the solution (the shortest path) ",(0,n.kt)("inlineCode",{parentName:"p"},"d"),". This can be expressed\nas ",(0,n.kt)("inlineCode",{parentName:"p"},"O(b^d)"),", where ",(0,n.kt)("inlineCode",{parentName:"p"},"b")," is the branching factor (the average number of successors per state) per stage."),(0,n.kt)("p",null,"In weighted graphs, edge weights should be non-negative. Like in the implementation of Dijkstra's algorithm, A","*"," is\nimplemented with the priority queue provided by C++, to perform the repeated selection of minimum (estimated) cost nodes\nto expand. This is the ",(0,n.kt)("inlineCode",{parentName:"p"},"open_set"),". If the shortest path is not unique, one of the shortest paths is returned."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/A*_search_algorithm"},"wikipedia")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.redblobgames.com/pathfinding/a-star/introduction.html"},"Red Blob Games"))),(0,n.kt)("h2",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"calculates the shortest path between on start_vertex and one end_vertex using A","*"," search.\nWorks on both weighted as well as unweighted graphs. For unweighted graphs, a unit weight is used for each edge."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename V, typename E, graph_type T, typename HEURISTIC_T, typename WEIGHT_T = decltype(get_weight(std::declval<E>()))>\n  requires std::is_invocable_r_v<WEIGHT_T, HEURISTIC_T&, vertex_id_t>\nstd::optional<graph_path<WEIGHT_T>> a_star_search(\n    const graph<V, E, T> &graph, vertex_id_t start_vertex, vertex_id_t target_vertex,\n    const HEURISTIC_T &heuristic);\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"graph")," The graph to extract shortest path from."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"start_vertex")," The vertex id where the shortest path should should start."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"target_vertex")," The vertex id where the shortest path should end."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"heuristic")," A heuristic function estimating the cost from a vertex to the target."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"return"),"  An optional containing the shortest path (a list of vertices) if found, or std::nullopt if no such path\nexists.")))}m.isMDXComponent=!0}}]);