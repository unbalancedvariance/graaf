"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[986],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>u});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var o=r.createContext({}),p=function(e){var t=r.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},h=function(e){var t=p(e.components);return r.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),c=p(a),m=n,u=c["".concat(o,".").concat(m)]||c[m]||d[m]||i;return a?r.createElement(u,s(s({ref:t},h),{},{components:a})):r.createElement(u,s({ref:t},h))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[c]="string"==typeof e?e:n,s[1]=l;for(var p=2;p<i;p++)s[p]=a[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},9685:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const i={},s="Breadth First Search (BFS)",l={unversionedId:"algorithms/traversal/breadth-first-search",id:"algorithms/traversal/breadth-first-search",title:"Breadth First Search (BFS)",description:"Breadth First Search (BFS) Algorithm",source:"@site/docs/algorithms/traversal/breadth-first-search.md",sourceDirName:"algorithms/traversal",slug:"/algorithms/traversal/breadth-first-search",permalink:"/graaf/docs/algorithms/traversal/breadth-first-search",draft:!1,editUrl:"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/traversal/breadth-first-search.md",tags:[],version:"current",frontMatter:{},sidebar:"algorithmSidebar",previous:{title:"Traversal Algorithms",permalink:"/graaf/docs/category/traversal-algorithms"},next:{title:"Depth First Search (DFS)",permalink:"/graaf/docs/algorithms/traversal/depth-first-search"}},o={},p=[{value:"Breadth First Search (BFS) Algorithm",id:"breadth-first-search-bfs-algorithm",level:2},{value:"BFS is particularly useful for:",id:"bfs-is-particularly-useful-for",level:3},{value:"Limitations of BFS:",id:"limitations-of-bfs",level:4},{value:"Complexity and Performance:",id:"complexity-and-performance",level:3},{value:"Syntax",id:"syntax",level:2},{value:"Explanation of Parameters:",id:"explanation-of-parameters",level:3}],h={toc:p},c="wrapper";function d(e){let{components:t,...a}=e;return(0,n.kt)(c,(0,r.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"breadth-first-search-bfs"},"Breadth First Search (BFS)"),(0,n.kt)("h2",{id:"breadth-first-search-bfs-algorithm"},"Breadth First Search (BFS) Algorithm"),(0,n.kt)("p",null,"Breadth First Search (BFS) is a fundamental graph traversal algorithm used to explore and analyze graphs, be they\ndirected or undirected. It operates on the principle of visiting nodes in layers, starting from a given source node and\ngradually expanding outward to neighboring nodes at increasing distances. BFS ensures that all nodes at a particular\ndistance from the source are visited before moving on to nodes at a greater distance. This process continues until all\nreachable nodes have been visited, forming a breadth-first exploration of the graph."),(0,n.kt)("p",null,"The BFS algorithm can be succinctly described using the following steps:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Begin by selecting a source node as the starting point of the traversal and enqueue it in a queue data structure.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"While the queue is not empty, repeat the following steps:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"a. Dequeue a node from the front of the queue."),(0,n.kt)("li",{parentName:"ul"},"b. Process the dequeued node, which may involve examining its attributes, marking it as visited, or performing\nother relevant operations."),(0,n.kt)("li",{parentName:"ul"},"c. Enqueue all unvisited neighbors of the dequeued node into the queue."))),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},"Continue this process until the queue becomes empty, indicating that all reachable nodes have been visited."))),(0,n.kt)("h3",{id:"bfs-is-particularly-useful-for"},"BFS is particularly useful for:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"P2P - Find neighbor nodes:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Finds all neighbors, and then all neighbors of these neighbors."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Search Engine Crawler:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Helps in systematically crawling web pages, exploring links layer by layer."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Garbage Collection:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Identifies and marks reachable objects, propagating to related objects."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Broadcasting in Networks:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Efficiently distributes information across nodes in a network."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Analyzing the Connectivity of Components:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Determines the connected components in a graph."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Solving Puzzles like the Sliding Tile Puzzle:"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Explores possible moves in a puzzle in a systematic manner.")))),(0,n.kt)("h4",{id:"limitations-of-bfs"},"Limitations of BFS:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Memory Usage:")," BFS may consume significant memory resources, especially in graphs with many nodes or when\nsearching for paths in deep or complex graphs.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Performance on Dense Graphs:")," In dense graphs, where the number of edges is close to the maximum possible, BFS may\nnot perform as efficiently as other algorithms designed specifically for dense graphs.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Unweighted Graphs:")," BFS doesn't incorporate edge weights, which makes it less suitable for finding shortest paths\nin graphs with weighted edges.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"No Negative Weights:")," BFS is not suited for graphs with negative edge weights, as it assumes that all edges have a\nnon-negative weight. This is because BFS relies on the property that it visits nodes in increasing order of distance\nfrom the source, and negative weights can lead to unexpected results.")),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"No Guarantee of Optimality:")," While BFS can find the shortest path in an unweighted graph, it may not guarantee the\nshortest path in graphs with weighted edges or other more complex scenarios. Dijkstra's algorithm or the Bellman-Ford\nalgorithm are better suited for such cases."))),(0,n.kt)("h3",{id:"complexity-and-performance"},"Complexity and Performance:"),(0,n.kt)("p",null,"The BFS algorithm is implemented with a priority queue and runs in ",(0,n.kt)("inlineCode",{parentName:"p"},"O(|V| + |E|)")," time complexity for connected graphs,\nwhere ",(0,n.kt)("inlineCode",{parentName:"p"},"|E|")," is the number of edges and ",(0,n.kt)("inlineCode",{parentName:"p"},"|V|")," the number of vertices in the graph."),(0,n.kt)("p",null,"In summary, Breadth First Search is a powerful and versatile algorithm for exploring graphs, but its limitations in\nhandling weighted graphs and negative edge weights should be considered. It provides a straightforward way to explore a\ngraph layer by layer and is particularly useful for unweighted graph scenarios and connectivity analysis."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Breadth-first_search"},"wikipedia")),(0,n.kt)("h2",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"The bfs_termination_strategy returns true when a certain condition is met, causing to terminate. The bfs_edge_callback\nis a function that is used as a callback during the BFS traversal to perform some action whenever an edge is traversed."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"template <\n    typename V, typename E, graph_type T,\n    typename EDGE_CALLBACK_T = detail::noop_callback,\n    typename SEARCH_TERMINATION_STRATEGY_T = detail::exhaustive_search_strategy>\n  requires std::invocable<EDGE_CALLBACK_T &, edge_id_t &> &&\n           std::is_invocable_r_v<bool, SEARCH_TERMINATION_STRATEGY_T &,\n                                 vertex_id_t>\nvoid breadth_first_traverse(\n    const graph<V, E, T> &graph, vertex_id_t start_vertex,\n    const EDGE_CALLBACK_T &edge_callback,\n    const SEARCH_TERMINATION_STRATEGY_T &search_termination_strategy =\n        SEARCH_TERMINATION_STRATEGY_T{});\n")),(0,n.kt)("h3",{id:"explanation-of-parameters"},"Explanation of Parameters:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"graph"),": The graph to traverse. This parameter represents the graph data structure on which the traversal will be\nperformed."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"start_vertex"),": Vertex id where the traversal should be started. This parameter specifies the initial vertex from\nwhich the traversal begins."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"edge_callback"),": A callback function that is called for each traversed edge. It should be invocable with\nan ",(0,n.kt)("inlineCode",{parentName:"li"},"edge_id_t")," object, representing an edge in the graph."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"search_termination_strategy"),": A unary predicate that indicates whether the traversal should continue or not. The\ntraversal continues while this predicate returns ",(0,n.kt)("inlineCode",{parentName:"li"},"false"),". This parameter is optional and defaults to a predefined\nsearch termination strategy, which traverses the graph exhaustively."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"return"),": The provided code does not explicitly return a value. The traversal is performed by visiting vertices and\nedges in the graph based on the specified parameters.")))}d.isMDXComponent=!0}}]);