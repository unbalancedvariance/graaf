"use strict";(self.webpackChunkgraaf=self.webpackChunkgraaf||[]).push([[400],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>u});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var i=a.createContext({}),h=function(e){var t=a.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},p=function(e){var t=h(e.components);return a.createElement(i.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=h(r),m=n,u=c["".concat(i,".").concat(m)]||c[m]||d[m]||o;return r?a.createElement(u,l(l({ref:t},p),{},{components:r})):a.createElement(u,l({ref:t},p))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,l=new Array(o);l[0]=m;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[c]="string"==typeof e?e:n,l[1]=s;for(var h=2;h<o;h++)l[h]=r[h];return a.createElement.apply(null,l)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},7533:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=r(7462),n=(r(7294),r(3905));const o={},l="Floyd-Warshall algorithm",s={unversionedId:"algorithms/shortest-path/floyd-warshall",id:"algorithms/shortest-path/floyd-warshall",title:"Floyd-Warshall algorithm",description:"Floyd-Warshall algorithm computes the shortest path between any two vertices in a graph, both directed and undirected.",source:"@site/docs/algorithms/shortest-path/floyd-warshall.md",sourceDirName:"algorithms/shortest-path",slug:"/algorithms/shortest-path/floyd-warshall",permalink:"/graaf/docs/algorithms/shortest-path/floyd-warshall",draft:!1,editUrl:"https://github.com/bobluppes/graaf/tree/main/docs/algorithms/shortest-path/floyd-warshall.md",tags:[],version:"current",frontMatter:{},sidebar:"algorithmSidebar",previous:{title:"Dijkstra Shortest Path",permalink:"/graaf/docs/algorithms/shortest-path/dijkstra"},next:{title:"Strongly Connected Component Algorithms",permalink:"/graaf/docs/category/strongly-connected-component-algorithms"}},i={},h=[{value:"Syntax",id:"syntax",level:2}],p={toc:h},c="wrapper";function d(e){let{components:t,...r}=e;return(0,n.kt)(c,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"floyd-warshall-algorithm"},"Floyd-Warshall algorithm"),(0,n.kt)("p",null,"Floyd-Warshall algorithm computes the shortest path between any two vertices in a graph, both directed and undirected.\nThe algorithm does not work for graphs with negative weight cycles.\nThe key idea of the algorithm is to relax the weighted shortest path between any two vertices, using any vertex as an\nintermediate one.\nAdvantage of the algorithm is that it processes vertices instead of edges. This advantage can be used when the number of\nedges is large enough, aka a dense graph.\nRuntime of the algorithm is O(|V",(0,n.kt)("sup",null,"3"),"|) and memory consumption is O(|V",(0,n.kt)("sup",null,"2"),"|)."),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm"},"wikipedia")),(0,n.kt)("h2",{id:"syntax"},"Syntax"),(0,n.kt)("p",null,"Calculates the shortest path between any two vertices."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename V, typename E, graph_type T,\n          typename WEIGHT_T = decltype(get_weight(std::declval<E>()))>\nstd::vector<std::vector<WEIGHT_T>> floyd_warshall_shortest_paths(\n    const graph<V, E, T>& graph);\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"graph")," The graph to extract the shortest path from."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"return")," Returns a 2D vector of the shortest path. If a path doesn't exist between two vertices, mark it as\nTYPE_MAX.")))}d.isMDXComponent=!0}}]);